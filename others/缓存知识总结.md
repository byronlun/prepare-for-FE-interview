# 缓存知识总结

标签： 前端

---

本文参考链接: [浏览器缓存知识小结及应用](http://www.cnblogs.com/lyzg/p/5125934.html)

这篇文章主要总结一下浏览器缓存(服务器端设置)以及通过其他前端技术设置的缓存。

## 浏览器缓存基本认识

分为强缓存和协商缓存: 

1. 浏览器在加载资源时，先根据这个资源的一些 http header 判断它是否命中强缓存，强缓存如果命中，浏览器就不会发送请求到服务器，直接从他自己的缓存中读取资源。
2. 当强缓存没有命中的时候，浏览器一定会发送一个请求到服务器，通过服务器端根据资源的另外一些http header 验证这个资源是否命中协商缓存，如果命中协商缓存的话，服务器就不返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源，于是浏览器就又会从自己的缓存中去加载这个资源；
3. 强缓存与协商缓存的共同点是：如果命中，都是从客户端缓存中加在资源，而不用从服务器加在资源；区别是：强缓存步发请求到服务器，而协商缓存需要发请求到服务器；
4. 当协商缓存也没有命中的话，那么浏览器就直接从服务器加在资源数据。

## 强缓存的原理

当浏览器对某个资源的请求命中了强缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为 `from cache` 。

强缓存是利用 `Expires` 或者 `Cache-Control` 这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。

`Expires` 是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：`Expires:Thu, 31 Dec 2037 23:55:55 GMT`。

**Expires它的缓存原理**是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在响应头信息中加上 `Expires` 这个头部信息。
2. 浏览器接受资源后，会把这个资源连同所有的header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）。
3. 浏览器再次请求这个资源时，先从缓存中寻找，如果找到这个资源，拿出它的 `Expires` 跟当前的请求时间比较，如果请求时间在 `Expires` 指定的时间之前，就能命中缓存，否则就不行。
4. 如果缓存没有命中，浏览器直接从服务器加载资源时，`Expires` 的header在重新加载的时候会被更新。

`Expires` 是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，比如随意修改下客户端时间，就能影响缓存命中的结果。所以在http1.1的时候，提出了一个新的header，就是 `Cache-Control`，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，如：Cache-Control:max-age=315360000。

**Cache-Control的缓存原理**是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在响应头信息中加上 `Cache-Control` 这个头部信息。
2. 浏览器接受资源后，会把这个资源连同所有的header一起缓存下来。
3. 浏览器再次请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 `Cache-Control` 设定的有效期，**计算出一个资源过期时间**，再**拿这个过期时间跟当前的请求时间比较**，如果请求时间在过期时间之前，就能命中缓存，否则就不行。
4. 如果缓存没有命中，浏览器直接从服务器加载资源时，`Cache-Control` 的 header在重新加载的时候会被更新。

`Cache-Control` 描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较 `Expires`，`Cache-Control` 的缓存管理更有效，安全一些。

注意： **这两个header可以只启用一个，也可以同时启用，当response header中，`Expires` 和 `Cache-Control` 同时存在时，`Cache-Control` 优先级高于 `Expires`**。

## 强缓存的管理

前面介绍的是强缓存的原理，在实际应用中我们会碰到需要强缓存的场景和不需要强缓存的场景，通常有2种方式来设置是否启用强缓存：

1. 通过代码的方式，在web服务器返回的响应中添加 `Expires` 和 `Cache-Control` Header。
2. 通过配置web服务器的方式，让web服务器在响应资源的时候统一添加 `Expires` 和 `Cache-Control` Header。

**这两种方式都是在服务器端设置响应头信息来设置缓存**。

强缓存是前端性能优化最有力的工具，没有之一（因为根本就不用去服务器请求资源），对于有大量静态资源的网页，一定要利用强缓存，提高响应速度。通常的做法是，为这些静态资源全部配置一个超时时间超长的 `Expires` 或 `Cache-Control` ，这样用户在访问网页时，只会在第一次加载时从服务器请求静态资源，其它时候只要缓存没有失效并且用户没有强制刷新的条件下都会从自己的缓存中加载。

## 协商缓存的原理

当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个 `Not Modified` 的字符串。
协商缓存利用的是 【`Last-Modified`,`If-Modified-Since`】和【`ETag`，`If-None-Match`】这两对Header来管理。

**【`Last-Modified`，`If-Modified-Since`】的控制缓存的原理**是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上 `Last-Modified` 的header，这个header表示这个资源在服务器上的最后修改时间。
2. 浏览器再次跟服务器请求这个资源时，在request的header上加上 `If-Modified-Since的header`，这个header的值就是上一次请求时返回的 `Last-Modified` 的值。
3. 服务器再次收到资源请求时，根据浏览器传过来 `If-Modified-Since` 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 `304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。
4. 浏览器收到304的响应后，就会从缓存中加载资源。
5. 如果协商缓存没有命中，浏览器直接从服务器加载资源时，`Last-Modified`  Header在重新加载的时候会被更新，下次请求时，`If-Modified-Since` 会启用上次返回的 `Last-Modified` 值。

【`Last-Modified`，`If-Modified-Since`】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的。

**为什么要有Etag**

你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，`If-Modified-Since` 能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器不能精确的得到文件的最后修改时间。

于是就有了【`ETag`、`If-None-Match`】这对 header。

**【`ETag`，`If-None-Match`】的控制缓存的原理**是：

1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上 `ETag` 的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 `Last-Modified` 的问题。
2. 浏览器再次跟服务器请求这个资源时，在request的header上加上 `If-None-Match` 的header，这个header的值就是上一次请求时返回的 `ETag` 的值。
3. 服务器再次收到资源请求时，根据浏览器传过来 `If-None-Match` 和然后再根据资源生成一个新的 `ETag`，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 `304 Not Modified`，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 `Last-Modified` 不一样的是，当服务器返回 `304 Not Modified` 的响应时，由于 `ETag` 重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。
4. 浏览器收到304的响应后，就会从缓存中加载资源。

##  协商缓存的管理

协商缓存跟强缓存不一样，强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。大部分web服务器都默认开启协商缓存，而且是同时启用【`Last-Modified`，`If-Modified-Since`】和【`ETag`、`If-None-Match`】。

【`Last-Modified`，`If-Modified-Since`】和【`ETag`、`If-None-Match`】一般都是同时启用，这是为了处理 `Last-Modified` 不可靠的情况。有一种场景需要注意：
1. 分布式系统里多台机器间文件的 `Last-Modified` 必须保持一致，以免负载均衡到不同机器导致比对失败。
2. 分布式系统尽量关闭掉 `ETag` (每台机器生成的 `ETag` 都会不一样）。

## 浏览器行为对缓存的影响

上面已经说了浏览器默认的处理方式，这个方式有可能被浏览器下面的行为所改变：

- 当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存
- 当f5刷新网页时，跳过强缓存，但是会检查协商缓存

## HTML5设置缓存技术

- localstorage 是一种本地存储的公共资源
- service worker用于离线缓存（[cacheStorage](https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage)就是通过其实现）
- IndexDB 是一种灵活且功能强大的数据存储机制，它集合了 Dom Storage 和 Web SQL Database 的优点，用于存储大块或复杂结构的数据，提供更大的存储空间，使用起来也比较简单。可以作为 Web SQL Database 的替代。不太适合静态文件的缓存。

关于IndexDB的了解，这里可以补充一下demo：chrome浏览器下的智能推荐页面就是通过IndexDB实现。
在chrome浏览器新建标签的时候，可以看到如下图这样的智能推荐页面：

![](http://ww1.sinaimg.cn/large/005JoIL8gy1fcoy2y7faij30jw0ea0xb)

打开开发者工具，在 Application 中的 Storage 里面打开IndexDB可以看到如下数据：

![](http://ww1.sinaimg.cn/large/005JoIL8gy1fcoy6a15nlj30z80hlae2)


注意： localstorage 在PC上的兼容性不太好，而且当网络速度快、协商缓存响应快时使用 localStorage 的速度比不上304。并且不能缓存css文件。而移动端由于网速慢，使用localStorage要快于304。

## CDN缓存

CDN缓存属于Cache服务器的一种。
CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络"边缘"，使用户可 以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因。

使用了CDN缓存后的网站的访问过程为：

1. 用户向浏览器提供要访问的域名；
2. 浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库一般得到的是该域名对应的CNAME记录（由于现在已经是使用了CDN服务，CNAME为CDN服务商域名），为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。（CDN服务来提供最近的服务器）
3. 此次解析得到CDN缓存服务器的IP地址，浏览器在得到实际的IP地址以后，向缓存服务器访问请求；
4. 缓存服务器根据浏览器提供的要访问的域名，通过Cache内部专用DNS解析得到此域名的实际IP地址，再由缓存服务器向此实际IP地址提交访问请求；
5. 缓存服务器从实际IP地址得得到内容以后，一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程；
6. 客户端得到由缓存服务器返回的数据以后显示出来并完成整个浏览的数据请求过程。

## 优秀文章

[缓存策略](http://imweb.io/topic/55c6f9bac222e3af6ce235b9)

