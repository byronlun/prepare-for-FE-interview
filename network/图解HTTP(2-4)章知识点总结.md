# 图解HTTP(2~4)章知识点总结

标签（空格分隔）： http js

---

## 第2章 简单的HTTP协议

### HTTP是不保存状态的协议

HTTP是一种不保存状态，即无状态（stateless）协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过得请求或响应都不做持久化处理。

这是为了更好地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。

可是，随便Web的不断发展，无状态协议对处理业务变得更加复杂麻烦，比如，用户登陆之后跳转到其他页面，就需要保存用户的登陆状态。因此，HTTP/1.1虽然是无状态协议，但为了实现期望的保存状态功能，引入了Cookie技术。

### Cookie

Cookie技术通过在请求和响应报文中写入Cookie信息来控制客户端的状态。

Cookie会根据从服务器端发送的响应报文内的一个叫做set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发送过去。

### URI(Uniform Resource Identifier)

URI就是由某个协议方案表示的资源的定位标识符。协议方案是指访问资源所使用的协议类型名称。当使用HTTP协议时，协议方案就是http。除此之外，还有ftp，mailto，telnet等。

**URI格式**

![](http://ww2.sinaimg.cn/large/005JoIL8gw1fbrai3dgpqj30j4042dga.jpg)

其中**登录信息**指定用户名和密码作为从服务器端获取资源时必要的登录信息。此项是可选项。


**区分URI，URL，URN**

URI：Uniform Resource Identifier，统一资源标识符；
URL：Uniform Resource Locator，统一资源定位符；
URN：Uniform Resource Name，统一资源名称。

关于URL：

>URL是URI的一种，不仅标识了Web 资源，还指定了操作或者获取方式，同时指出了主要访问机制和网络位置。

关于URN：

>URN是URI的一种，用特定命名空间的名字标识资源。使用URN可以在不知道其网络位置及访问方式的情况下讨论资源。

现在展示一个例子，非常简单清楚地说明在互联网中URI 、URL和URN之间的不同。

我们一起来看下面这个虚构的例子。这是一个URI：

```
http://test.io/posts/hello.html#intro
```

我们开始分析

```
http://
```

是定义如何访问资源的方式。另外

```
test.io/posts/hello.html
```

是资源存放的位置，那么，在这个例子中，

```
#intro
```

是资源。

URL是URI的一个子集，告诉我们访问网络位置的方式。在我们的例子中，URL应该如下所示：

```
http://test.io/posts/hello.html
```

URN是URI的子集，包括名字（给定的命名空间内），但是不包括访问方式，如下所示：

```
test.io/posts/hello.html#intro
```

### HTTP Methods

**GET: 获取资源**

GET方法用来请求访问已被URI识别的资源。指定的资源经服务器端解析后放回相应内容。

**POST: 传输实体主体**

POST方法用来传输实体的主体。虽然用GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用POST方法。POST的主要目的不是获取相应的主体内容。

**PUT: 传输文件**

PUT方法用来传输文件。就像FTP协议的文件上传一样，要求在请求保温的主体中包含文件内容，然后保存到请求URI指定的位置。

**HEAD: 获得报文首部**

HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。

**DELETE: 删除文件**

DELETE方法用来删除文件，是与PUT相反的方法。DELETE方法请按请求URI删除指定的资源。

**OPTIONS: 询问支持的方法**

OPTIONS方法用来查询针对请求URI指定的资源支持的方法。

**TRACE: 追踪路径**

TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。

**CONNECT: 要求用隧道协议连接代理**

CONNECT方法要求在代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后经网络隧道传输。

### 持久连接（HTTP/1.1提出）

HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。这样子每次的请求都会造成无谓的TCP连接建立和断开，增加通信量的开销。

于是为了解决这个问题，HTTP/1.1提出提出了持久链接（HTTP Persistent Connections， 也称为HTTP keep-alive）方法。即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。

所以，持久连接的好处在于减少了TC连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使HTTP请求和响应能够更早地结束，这样Web页面的显示速度就相应提高了。

### 管道机制

HTTP/1.1 还引入了**管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求**。这样能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。这样就进一步改进了HTTP协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送  A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

## 第3章 HTTP报文内的HTTP信息

HTTP报文大致可分为报文首部和报文主体两块。

### 编码提升传输效率

HTTP在传输数据时可以通过编码提升传输效率。通过在传输时编码，能有效地处理大量的访问请求。

HTTP报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体，**只有当传输中进行编码操作时，实体主体的内容发生改变，才导致和报文主体产生差异**。

1. 压缩传输的内容编码： HTTP协议中有一种被称为内容编码的功能，指明了应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。
2. 分割发送的分块传输编码： 在传输大容量数据时，通过吧数据分割成多块，能够让浏览器逐步显示页面，这种把实体主体分块的功能称为分块传输编码。使用分块传输编码的实体主体会由接受的客户端负责编码，恢复到编码前的实体主体。

### 内容协商

同一个Web网站可能攒再多分相同内容的页面，比如英文版和中文版的页面。当浏览器的默认语言为英语或中文，访问相同URI的Web页面时，则会显示对应的英语班或中文版的Web页面。这样的机制称为内容协商。

内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供客户端最为合适的资源。内容协商会以响应的资源的语言，字符集，编码方式等作为判断的基准。包含在请求报文的某些首部字段（例如： `Accept`， `Accept-Charset`， `Accept-Encoding`， `Accept-Language`， `Content-Language`）就是判断的基准。

内容协商技术有三种类型。

- 服务器驱动协商
- 客户端驱动协商
- 透明协商（两者结合）

## 第4章 HTTP状态码

![](http://ww1.sinaimg.cn/large/005JoIL8gy1fdurj6icc6j30ll082adh.jpg)

### 1xx

1xx表示请求已被接受，但需要后续处理。

>100（Continue）：客户端应继续发送请求。

>101（Switching Protocols）：需要切换协议，服务器通过的Upgrade响应头字段通知客户端。
HTML5引入的WebSocket便是这样工作的。首先客户端请求websocket所在的URL，服务器返回101，然后便建立了全双工的TCP连接。 注意Upgrade和Connection头字段属于Hop-by-hop字段，设置Websocket代理时需要继续设置这两个字段，而不是简单地转发请求。

### 2xx 

2xx的响应结果表明**请求被正常处理**。

>1）200 OK：表示从客户端发来的请求在服务器端被正常处理

>2）204 No Content：请求处理成功，但无资源可返回。代表服务器接收的请
求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回
任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏
览器显示的页面不发生更新。

>3）206 Partial Content：对资源某一部分的请求。表示客户端进行了范围
请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-
Range 指定范围的实体内容。（[断点续传的原理](http://www.codetc.com/article-76-1.html)）


### 3xx

3XX 响应结果表明**浏览器需要执行某些特殊的处理以正确处理请求**。

>1）301 Moved Permanently 
永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。
也就是说，如果已经把资源对应的URI保存为书签了，这时应该按Location 首部字段提示的 URI 重新保存。

>2）302 Found 
临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。

>**和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。**

>301重定向与302重定向的区别:
　　**302重定向是暂时的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。 SEO 302好于301
　　301重定向是永久的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。**

>3）303 See Other 
表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。

>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。

>4）304 Not Modified 
资源已找到，但未复合条件请求。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。**304 虽然被划分在 3XX 类别中，但是和重定向没有关系。**

>5）307 Temporary Redirect 
临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。

### 4xx

4XX 的响应结果表明**客户端是发生错误的原因所在**。

>1）400 Bad Request 
该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。

>2）401 Unauthorized 
该状态码表示发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息。另外，若之前已进行过一次请求，则表示用户认证失败。返回含有401的响应必须包含一个适用于被请求资源的WWW-Authenticate首部用以质询用户信息。当浏览器初次接收到401响应，会弹出认证用的对话窗口。

>3）403 Forbidden 
表示请求资源的访问被服务器拒绝。未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。

>4）404 Not Found 
表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。

### 5xx

5XX 的响应结果表明5XX 的响应结果表明服务器本身发生错误。

>1）500 Internal Sever Error 
表示服务器端执行请求时发生了错误。也有可能是 Web 应用存在的 bug或某些临时的故障。

>2）503 Service Unavailable 
表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 Retry After 首部字段再返回给客户端。


## 优秀文章

[HTTP1.1与前端性能](http://imweb.io/topic/554c5879718ba1240cc1dd8a)
