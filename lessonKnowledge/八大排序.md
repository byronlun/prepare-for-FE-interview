# 八大排序

标签： 数据结构

---

Table of Content

- [冒泡排序](#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
- [选择排序](#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F)
- [插入排序](#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F)
- [快速排序](#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F)
- [堆排序](#%E5%A0%86%E6%8E%92%E5%BA%8F)
- [希尔排序](#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F)
- [归并排序](#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F)
- [基数排序](#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F)

## 冒泡排序

实现思想是比较相邻元素并将比较大或者比较小的元素往后移。每扫描一轮，就确定一个元素的位置。

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 交换 | On2 | On | On2 | 稳定 |

代码是肯定要会写的：D

```js
function bubleSort(a) {
    var tmp = 0,
        n = a.length;
    for (var i = 0; i < n; ++i) {
        for (var j = 1; j < n - i; j++) {
            if (a[j] < a[j - 1]) {
                tmp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = tmp;
            }
        }
    }
    return a;
}
```

### 冒泡排序的优化

对冒泡排序的优化，主要是**减少比较次数**。如果一次扫描中元素没有发生交换，那么排序就可以结束了。为此可以设置一个标志量 `flag`，默认为 `false`，如果扫面中发生交换了则把 `flag` 置为 `true`，下轮扫描前先检查这个变量，如果 `flag` 为 `false` 则排序结束。
更进一步，可以记录每次扫描中最后一次交换的位置，下次扫描的时候只要扫描到上次的最后交换位置就行了，因为后面的都是已经排好序的，无需再比较。
代码如下：

```js
//第一种优化
function optimizeBuble_1(a) {
    var tmp = 0,
    	flag = true,
		n = a.length;
    for (var i = 0; i < n && flag; ++i) {
    	flag = false;
		for (var j = 1; j < n - i; j++) {
			if (a[j] < a[j - 1]) {
				tmp = a[j];
				a[j] = a[j - 1];
				a[j - 1] = tmp;
				flag = true;
			} 
		}
    }
    return a;
}

// 第二种优化
function optimizeBuble_2(a) {
    var tmp = 0,
		k = a.length,
		flag = k;  //flag用于记录每轮扫描发生交换的最后位置
    while (flag > 0) {
        k = flag;
        flag = 0;
        for (var j = 1; j < k; ++j) {
            if (a[j] < a[j - 1]) {
                tmp = a[j];
                a[j] = a[j - 1];
                a[j - 1] = tmp;
                flag = j;
            }
        }
    }
    return a;
}
```

## 选择排序

实现思想是选择一个最小的数，记录下标，然后与第一个交换

实现思想是： 一次选定数组中的一个数，记下当前位置并假设它是从当前位置开始后面数中的最小的数 `min=i`，然后从这个数开始扫描到最后一个数，并记录最小数的位置 `min`，扫描结束后如果 `min` 不等于 `i`，则交换 `min` 和 `i` 的值。

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 选择 | On2 | On2 | On2 | 不稳定 |

选择也是要会写的：D

```js
function chooseSort (a) {
	var i,j,temp,min,len = a.length;
	for(i = 0; i < len-1; i++) {
		min = i;
		for(j = i + 1; j < len; j++) {
			if(a[i] > a[j]) {
				min = j
			}
		}
		if (min !== i) {
			temp = a[i];
			a[i] = a[min];
			a[min] = temp;
		}
	}
	return a
}
```

## 插入排序

实现思想是循环把一个数插入到有序序列中，其实所谓的插入就是不断地向后挪位（默认前面是有序数组，然后每次从后面的元素中拿出一个元素来插入，插入的步骤是往前面有序队列的队尾开始插入，然后往前遍历，直到遇到第一个小玉或者等于待插入元素的元素为止，则将待插入元素插入到该元素后面）

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 插入 | On2 | On | On2 | 稳定 |

## 快速排序

实现思想是首先选择一个基准元素，一般是第一个元素或者最后一个元素，然后右指针找比基准数小的，左指针找比基准数大的，然后交换，经过几次交换之后，两个指针会相遇在一个数上，然后与基准数交换。这时就会形成基准数的左边的数都比基准数小，右边的数都比基准数大。然后根据同样的方式递归左右两个子序列

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 交换 | Onlog2n | Onlog2n | On2 | 不稳定 |


## 堆排序

利用大顶堆可以进行升序，反之，利用小顶堆进行降序排序

例如我们要实现升序，我们就要构造大顶堆，然后把堆顶和最后一个元素交换，然后输出最后一个元素，然后在剩下的元素中再次构造大顶堆，一直递归下去

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 选择 | Onlog2n | Onlog2n | Onlog2n | 不稳定 |

## 希尔排序

实现思想是按照某一个增量分成若干组，第一次增量为排序数的一半，每组的下标相差都是这个增量，然后每组的全部元素进行插入排序，排序完后，增量减小为原来增量的一半，再次进行分组和排序，当增量为 1，进行插入排序之后，排序完成

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 插入 | On1.3 | On | On2 | 不稳定 |

## 归并排序

归并排序就是递归合并，关键是如何将两个有序序列合并成一个，合并的次数为 log2n

合并的算法如下

1. 定义变量 `i`，从 0 开始，依次为 A 序列中每个元素的索引
2. 定义就是 `j`，从 0 开始，依次为 B 序列中每个元素的索引
3. 拿 `i` 索引的元素和 `j` 索引元素比较，将较小的复制到一个临时数组中
4. 如果 `i` 小，`i++`；如果 `j` 小，`j++`
5. 直到其中一个序列里的全部元素都放到临时数组里后，将另一个数组多出来的元素全部放进临时数组里，合并完成

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 归并 | Onlog2n | Onlog2n | Onlog2n | 稳定 |

## 基数排序

实现思想是通过收集和分配，分配对数字的个位，十位，百位等关键字进行排序，需要引入 `count` 和 `pos` 数组来存放关键字的个数和起始位置，那么我们的数字就不需要比较也不需要交换，直接跟据这个 `pos` 的值，放到对应的位置，每放置一个数，`pos` 的值加 1

| 类型 | 平均时间复杂度 | 最好时间复杂度 | 最坏时间复杂度 | 稳定性 |
|:---:|:---:|:---:|:---:|:---:|
| 基数 | O(d(r+n)) | O(d(n+rd)) | O(d(r+n)) | 稳定 |

d 是数组的长度，n 是关键字的个数，r 是关键字的基数

## 扩展阅读

[JavaScript排序，不只是冒泡](https://segmentfault.com/a/1190000008796659?utm_source=weekly&utm_medium=email&utm_campaign=email_weekly)
